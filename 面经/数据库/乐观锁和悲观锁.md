# 乐观锁和悲观锁

**乐观锁：** 乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。 诸如GIT,SVN,CVS等代码版本控制管理器，就是一个乐观锁使用很好的场景。

> CAS算法有一个问题那就是会产生ABA问题，而常用的解决方式就是加上版本号。

**悲观锁：** 悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等都是在做操作之前先上锁，以及syncronized实现的锁均为悲观锁。悲观锁在并发量非常大的时候，由于锁消耗资源、锁定时间过长等原因，很容易导致系统性能下降，资源消耗严重。因此一般我们可以在并发量不是很大，并且出现并发情况导致的异常用户和系统都很难以接受的情况下，选择悲观锁进行。

> 参考资料：https://blog.csdn.net/qq_14996421/article/details/106351873