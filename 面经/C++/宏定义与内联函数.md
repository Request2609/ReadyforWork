# 宏定义

在程序的预编译（预处理）阶段，会将宏定义的符号在源程序中进行替换，简单的诸如`#define pi 3.14`，或是用宏定义参数，即带参数的宏，如`#define MUL(a,b) a*b`，而需要注意的是，带参的宏定义的参数是没有类型的，因此不会做类型检查。

宏有两个缺陷：

1. 宏不能访问对象的私有成员；
2. 宏的定义很容易产生二义性；（容易出错）

对于第2点，举例来说，如果用MUL(10+10)去调用前文所提宏的话，我们期望的结果是400，而宏的调用结果是(10+10\*10+10),结果是120，这显然不是我们要得到的结果。避免这些错误的方法，一般是给宏的参数都加上括号。如是：`#define MUL(x) ((x)*(x))`。

# 内联函数

C++使用inline关键字来定义内联函数。而且在类的声明部分定义了函数体的函数，不管是否有inline关键字，均被默认为是内联函数。（不过编译器会决定要不要将它内联）

在程序的编译阶段，编译器会将内联函数像宏一样的展开，从而减去了普通函数的传参、压栈等操作，减少了调用的开销。并且还可以像调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。

但同时内联函数使用不恰当是会有副作用的，会增加目标代码的大小，带来代码膨胀，还有可能引入难以发现的程序问题。不过inline关键字仅仅是建议编译器做内联展开处理，而不是强制，被inline修饰的函数并不是一定会被内联。如果内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。

**内联函数的使用应当要注意些什么？**

1.      在定义内联函数应当尽量定义成那些调用非常频繁而且函数功能简单的函数，而不能将函数实现很复杂的功能定义成内联
2.      由于内联函数在调用的时候直接暴露出了函数体，故会造成泄漏函数功能的现象
3.      在内联函数中尽量减少变量的申请，尽量简化内联函数的函数体，这也对程序结构有好处
4.      因为内联函数要在调用处展开，编译器必须能在每一个调用处能看到该函数的定义，因此最好将函数实现放在头文件中。
5.      在实现文件中该函数之前要加上inline关键字的方式是有问题的：如果调用的obj文件在函数定义之前生成，那么该处就无法嵌入内联函数了。

**哪些情况下函数不会被内联？**

1. 包含了递归、循环等结构的函数一般不会被内联。

2. 虚拟函数一般不会内联，但是如果编译器能在编译时确定具体的调用函数，那么仍然会就地展开该函数。

3. 如果通过函数指针调用内联函数，那么该函数将不会内联而是通过call进行调用。

4. 构造和析构函数一般会生成大量代码，因此一般也不适合内联。

5. 如果内联函数调用了其他函数也不会被内联。

