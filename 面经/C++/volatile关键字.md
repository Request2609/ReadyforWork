# volatile的作用

volatile是“易变的”、“不稳定”的意思。常用来解决变量在“共享”环境下容易出现读取错误的问题。

定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。

在单任务的环境中，一个函数体内部，如果在两次读取变量的值之间的语句没有对变量的值进行修改，那么编译器就会设法对可执行代码进行优化。由于访问寄存器的速度要快过RAM（从RAM中读取变量的值到寄存器），以后只要变量的值没有改变，就一直从寄存器中读取变量的值，而不对RAM进行访问。

而在多任务环境中，虽然在一个函数体内部，在两次读取变量之间没有对变量的值进行修改，但是该变量仍然有可能被其他的程序（如中断程序、另外的线程等）所修改。如果这时还是从寄存器而不是从RAM中读取，就会出现被修改了的变量值不能得到及时反应的问题。

例如：

```c++
#include <iostream>
using namespace std;

int main(int argc, char* argv[])
{
    int i = 10;
    int a = i;
    cout << a << endl;
    _asm
    {
        mov dword ptr [ebp - 4], 80
    }
    int b = i;
    cout << b << endl;
}

/*
程序在VS2012环境下生成Release版本，输出结果是：
10
10
*/
```

> 注意：
>
> * 以上代码必须在Release模式下考查，因为只有Release模式下才会对程序代码进行优化，而这种优化在变量共享的环境下容易引发问题；
> * 在语句`b = i;`之前，已经通过内联汇编代码修改了i的值，但是i的变化却没有反映到b中，如果i是一个被多个任务共享的变量，这种优化带来的错误很可能是致命的；
>
> * 汇编代码[ebp - 4]表示变量i的存储单元，因为ebp是扩展基址指针寄存器，存放函数所属栈的栈底地址，先入栈，占用4个字节。随着函数内申明的局部变量的增多，esp（栈顶指针寄存器）就会相应的减小，因为栈的生长方向由高地址向低地址生长。i为第一个变量，栈空间已被ebp入栈占用了4个字节，所以i的地址为ebp - 4，[ebp - 4]则表示变量i的存储单元。

而只需要在变量i定义前添加一个volatile，即把`int i = 10;`改为`volatile int i = 10;`，就可以抑制编译器对读取变量的这种优化，从而防止错误的读取。

```txt
修改后程序的输出结果为：
10
80
```

# volatile的应用场景

1. 多线程应用中被多个任务共享的变量需要加volatile；
2. 中断服务程序中修改的供其它程序检测的变量需要加volatile；
3. 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；