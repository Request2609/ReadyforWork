# 多态的底层实现

主要是利用虚函数表。先构建一个基类，然后在基类的构造函数中会建立虚函数表，也就是一个储存虚函数地址的数组，内存地址的前四个字节保存指向虚函数表的指针，然后当多个子类继承父类之后，主函数中可以通过父类指针调用子类的继承函数。

虚函数表属于类，也属于它的子类等各种派生类。虚函数表由编译器在编译时生成，保存在.rdata只读数据段。

**子类的多态函数是怎么被调用的？**

因为每个子类都继承并设置了自己的虚函数表，每次用父类指针创建新子类时就会出现，从而最终调用自己的表。

**怎么知道多态时，指向哪个虚函数？**

定义的父类指针new出哪个子类就是指向哪个子类的虚函数。

**虚函数表的结构是怎样的？**

虚函数表是一个函数指针数组，数组里存放的都是函数指针，指向虚函数所在的位置。 对象调用虚函数时，会根据虚指针找到虚表的位置，再根据虚函数声明的顺序找到虚函数在数组的哪个位置，找到虚函数的地址，从而调用虚函数。

# 虚函数的使用

**父类构造函数中是否可以调用虚函数？**

可以。不过调用会屏蔽多态机制，最终会把基类中的该虚函数作为普通函数调用，而不会调用派生类中的被重写的函数。

这是因为在定义子类对象的时候，会先调用父类的构造函数，而此时虚函数表以及子类函数还没有被初始化，为了避免调用到未初始化的内存，C++标准规范中规定了在这种情况下，即在构造子类时调用父类的构造函数，而父类的构造函数中又调用了虚成员函数，这个虚成员函数即使被子类重写，也不允许发生多态的行为。所以使用的是静态绑定，调用了父类的函数。

**构造函数可以是虚函数吗？为什么？**

不可以。虚函数对应一个vtable,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，无法调用。

**析构函数可以是虚函数吗？为什么？**

当析构函数是非虚函数时，主函数通过指针访问非虚函数时，编译器会根据指针的类型来确定要调用的函数；而指针是父类指针，所以调用父类的析构函数。

析构函数必须是虚函数。因为如果不是虚函数，当在主函数中用父类的指针new出一个子类对象，最后析构的时候，只会调用父类析构函数而不会调用子类析构函数。而且如果不为虚函数，父类指针就不会调用子类成员函数。

父类析构函数成为虚函数时，子类的析构函数会自动也变为虚函数。这个时候编译器会忽略指针的类型，而根据指针的指向来选择函数；也就是说，指针指向哪个类的对象就调用哪个类的函数。

**析构函数可以是纯虚函数么？**

析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。

**静态函数可以是虚函数么？为什么？**

static成员不属于任何类对象或类实例，所有的对象都共享这一份代码，他没有要动态绑定的必要性。

静态成员函数没有this指针，所以无法访问vptr，进而不能访问虚函数表。

**为什么C++不支持内联成员函数为虚函数？**

内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）

内联函数是在编译时期展开，而虚函数的特性是运行时才动态联编，所以两者矛盾，不能定义内联函数为虚函数。

**虚函数的安全性有什么问题？**

可以通过虚函数表，让父类指针访问子类的自有虚函数。这带来一定的安全问题。另外，即使父类的虚函数是私有函数或者保护函数，仍然可以通过虚函数表访问，带来一定的安全问题。