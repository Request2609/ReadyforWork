# 5种I/O模型

5种I/O模型分别是：

* 阻塞式I/O模型
* 非阻塞式I/O模型
* I/O复用模型
* 信号驱动式I/O模型
* 异步I/O模型

## I/O的概念

I/O（Input/Output，输入/输出）即数据的读取（接收）或写入（发送）操作。

内核会为每个I/O设备维护一个缓冲区。对于一个输入操作来说，进程I/O系统调用后，内核会先看缓冲区中有没有相应的缓存数据，如果有的话，就直接将数据复制到用户空间的进程缓冲区；如果没有的话，再到设备中读取，由于设备的I/O操作一般速度较慢，所以需要等待。

网络IO涉及用户空间和内核空间，一般会经历两个阶段：

（1）等待数据准备就绪，等待数据被内核读取到内核缓冲区中；

（2）把数据从内核缓冲区复制到应用进程缓冲区；

**阻塞和非阻塞的区别：** 

阻塞是指I/O操作需要彻底完成后才返回到用户空间；而非阻塞是指I/O操作被调用后立即返回给用户一个状态值，无需等到I/O操作彻底完成。

**同步和异步的区别：** 

POSIX把这两个术语定义如下：

同步I/O操作导致请求进程阻塞，直到I/O操作完成；

异步I/O操作不导致请求进程阻塞。

通俗来讲，同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去；异步是指进程在发起请求后，不需要一直等待下去，而是继续执行下面的操作，当有信息返回的时候会通知进程进行处理。

## 阻塞式I/O模型

调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等待这个函数返回才能进行下一步动作。用户进程全程阻塞直到两阶段完成，即，一阶段等待数据会阻塞，二阶段将数据从内核copy到用户空间也会阻塞，只有copy完数据后内核返回，用户进程才会解除阻塞状态，重新运行。

linux中的socket默认为阻塞式。

缺点：同一时刻只能处理一个操作，效率低。

结论：阻塞IO，两阶段都阻塞。

## 非阻塞式I/O模型

用户进程系统调用时，如果没有数据，则直接返回，不管事件有没有发生，若没有发生，则返回-1。因此一阶段数据准备不会阻塞用户进程。但是，用户进程需要不断的询问（即轮询）内核数据是否准备好（会造成CPU空转浪费资源）。当数据准备好时，用户进程会阻塞直到数据从内核空间copy到用户空间完成（二阶段），内核返回结果。

这里需要单独判断一下返回值为-1的情况，以recv 返回值为例，当返回值为-1时，需要先判断errno，errno为EAGAIN或EWOULDBLOCK, 表示无数据，这种情况下不是真正的系统错误，排除这个以后，表示遇到系统错误。含义：

* 大于0：接收数据完毕，返回值即收到的字节数
* 等于0：连接已经正常断开

缺点：忙轮询，需要占用CPU资源。

结论：非阻塞IO一阶段不阻塞，二阶段阻塞。

## I/O复用模型

多个进程或线程的I/O可以注册到一个复用器（select/poll/epoll）上，然后用一个进程或线程调用select/poll/epoll，这些函数可以同时阻塞多个I/O操作，并可在单个进程/线程中同时监听多个文件描述符，当任一描述符在内核缓冲区中有数据就绪时，这些函数就会返回；然后就可以对就绪的描述符再次发起I/O操作，读取内核中准备好的数据。

结论：两阶段都处于阻塞状态，优势在于可以通过单线程同时等待多个描述符就绪。

## 信号驱动式I/O模型

首先通过sigaction系统调用安装一个信号处理函数。当数据准备好时，内核就会为该进程产生一个SIGIO信号。随后既可以在信号处理函数中发起I/O操作读取数据，并通知主循环数据已经准备好待处理了，也可以立即通知主循环，让主循环来读取数据。

信号驱动式I/O模型的优势就在于它提供了消息通知机制，等待数据到达期间进程不被阻塞，主循环可以继续执行，不需要用户进程不断地轮询检查，减少了系统调用次数，提高了效率。

结论：一阶段不阻塞（异步），二阶段阻塞（同步）

## 异步I/O模型

告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到应用进程的缓冲区）完成后通知我们。

Linux中提供了异步IO的接口aio_read和aio_write，内核收到用户进程的aio_read之后会立即返回，不会阻塞，aio_read会给内核传递文件描述符，缓冲区指针，缓冲区大小，文件偏移等；当数据准备好，内核直接将数据copy到用户空间，copy完后给用户进程发送一个信号，进行用户数据异步处理（aio_read）。因此，异步IO中用户进程是不需要参与数据从内核空间copy到用户空间这个过程的，也即二阶段不阻塞。

可惜的是，在 Linux 下的异步 I/O 是不完善的，aio 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。

结论：两阶段都不阻塞

异步I/O模型与信号驱动式I/O模型的主要区别在于：后者是由内核通知我们何时可以启动一个I/O操作，而前者是由内核通知我们I/O操作何时完成。